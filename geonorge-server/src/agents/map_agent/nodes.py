"""
Node functions for the map agent workflow graph.
"""
import json
import re
import traceback
from typing import Dict
from langgraph.graph import END
from langchain.prompts import ChatPromptTemplate
from langchain.schema import StrOutputParser
from llm import LLMManager
from helpers.websocket import send_websocket_message
from ..utils.common import format_history, active_websockets
from ..utils.tool_utils import ToolInvocation
from ..utils.message_utils import get_last_message_by_role, standardize_state
from .tools.implementations import pan_to_location, set_zoom_level, add_markers, find_my_location, search_address

# Initialize LLM (needed for call_model and generate_response)
llm_manager = LLMManager()
llm = llm_manager.get_main_llm()

# --- Router Logic ---

def get_next_node(state: Dict) -> str:
    """Determine the next node in the workflow based on the message history."""
    print("--- DEBUG: get_next_node ---")
    messages = state.get("messages", [])
    if not messages:
        print("  No messages found, ending.")
        return END # Changed from "end" to END constant

    last_message_obj = messages[-1]
    print(f"  Last message object type: {type(last_message_obj)}")
    print(f"  Last message object: {last_message_obj}")

    role = None
    has_tool_calls = False

    # Handle dictionary format (common in LangGraph)
    if isinstance(last_message_obj, dict):
        role = last_message_obj.get("role")
        # Check for tool calls in additional_kwargs
        additional_kwargs = last_message_obj.get("additional_kwargs", {})
        has_tool_calls = bool(additional_kwargs.get("tool_calls")) if additional_kwargs else False
        # Also check if the role is directly 'tool'
        if role == 'tool':
             print("  Last message is a tool result (dict format).")
             return "response" # Tool results always go to generate response

    # Handle LangChain BaseMessage format (less common here but possible)
    elif hasattr(last_message_obj, "type"): # Check for 'type' attribute
        # Mapping from LangChain 'type' to simpler roles
        lc_type = getattr(last_message_obj, "type")
        if lc_type == "human": role = "human"
        elif lc_type == "ai": role = "assistant"
        elif lc_type == "tool": role = "tool"
        # Add other mappings if needed (system, function, etc.)

        # Check for tool calls attribute
        if hasattr(last_message_obj, "tool_calls"):
            has_tool_calls = bool(getattr(last_message_obj, "tool_calls"))
        elif hasattr(last_message_obj, "additional_kwargs") and isinstance(last_message_obj.additional_kwargs, dict):
             # Sometimes tool calls might still be nested in additional_kwargs for BaseMessages
             has_tool_calls = bool(last_message_obj.additional_kwargs.get("tool_calls"))

        if role == 'tool':
             print("  Last message is a tool result (BaseMessage format).")
             return "response" # Tool results always go to generate response

    else:
        print("  Last message is of unknown format.")
        return END # End if format is unrecognized

    print(f"  Determined Role: {role}, Has Tool Calls: {has_tool_calls}")

    # Routing logic based on determined role and tool calls
    if role == "human":
        print("  Routing to 'agent' (Human message).")
        return "agent"
    elif role == "assistant" and has_tool_calls:
        print("  Routing to 'tools' (Assistant message with tool calls).")
        return "tools"
    elif role == "assistant" and not has_tool_calls:
         # This is assumed to be the final response generated by the 'response' node.
         # Route directly to update to send the response and end the flow.
         print("  Routing to 'update' (Assistant message WITHOUT tool calls - assuming final response).")
         return "update" # Route directly to update, bypassing response node again.
    # Tool role handled above
    #elif role == "tool":
    #    print("  Routing to 'response' (Tool message).")
    #    return "response"

    print("  No matching condition found, ending.")
    return END # Default to end if no condition matches

async def router(state: Dict) -> Dict:
    """Simple pass-through router that preserves state."""
    # No modifications to state needed
    return state

# --- Agent Node: Calls Model ---

async def call_model(state: Dict) -> Dict:
    """Analyze the query and generate tool calls using the LLM."""
    print(f"Calling model with state: {state.keys()}")
    
    # Ensure there are messages
    messages = state.get("messages", [])
    if not messages:
        # No user query present, return unchanged state
        print("No messages found in state")
        return state
    
    # Get the latest user query
    latest_user_query = None
    for message in reversed(messages):
        if isinstance(message, dict) and message.get("role") == "human": # Ensure it's a dict
            latest_user_query = message.get("content")
            break
        elif hasattr(message, "type") and message.type == "human": # Handle BaseMessage
             latest_user_query = message.content
             break
    
    if not latest_user_query:
        print("No user query found")
        return state
    
    # Create system prompt for tool calling
    system_prompt = """Du er en kartassistent som hjelper brukere med å navigere kart.
    
    Basert på brukerens forespørsel, bestem hvilke karthandlinger som skal utføres og returner dem i JSON-format.
    
    Tilgjengelige verktøy:
    1. "PanMap" - Flytter kartet til en spesifisert lokasjon
       Format: {{"tool": "PanMap", "params": {{"location": "stedsnavnet"}}}} // Kan også ta koordinater hentet fra SearchAddress
       
    2. "ZoomMap" - Setter zoom-nivået på kartet (1-18)
       Format: {{"tool": "ZoomMap", "params": {{"level": zoom_level}}}}
       VIKTIG: "level" må være et heltall mellom 1 og 18, IKKE en streng som "increase" eller "decrease".
       
    3. "AddMarkers" - Legger til markører på kartet
       Format: {{"tool": "AddMarkers", "params": {{"locations": ["sted1", "sted2"], "clear": true/false}}}}
       
    4. "FindMyLocation" - Finner brukerens nåværende posisjon og sentrerer kartet på den
       Format: {{"tool": "FindMyLocation", "params": {{"zoom_level": 14, "add_marker": true/false}}}}
       Du kan også bruke add_marker parameteren for å legge til en markør på brukerens posisjon.
       
    5. "SearchAddress" - Søker etter en spesifikk norsk gateadresse for å finne koordinater og fullt navn.
      Format: {{"tool": "SearchAddress", "params": {{"address": "gatenavn nummer...", "add_marker": true/false}}}}
      VIKTIG:
        - Dette verktøyet finner koordinatene og sentrerer kartet der automatisk.
        - Kartet vil automatisk zoome til nivå 14 med mindre du også kaller "ZoomMap".
        - Bruk "add_marker": true for å legge til en markør på adressen.
        - Du trenger ikke å inkludere postnummer/poststed, men det kan hjelpe for å finne riktig adresse.
    
    Analyser brukerens forespørsel og returner en JSON-array med verktøykall som skal utføres.
    Eksempel (søk adresse): [{{"tool": "SearchAddress", "params": {{"address": "Eidsdalen 7B"}}}}] // Senterer kartet + zoomer til 14 automatisk
    Eksempel (søk adresse + marker): [{{"tool": "SearchAddress", "params": {{"address": "Storgata 1, Oslo", "add_marker": true}}}}] // Senterer kartet, zoomer til 14 auto + marker
    Eksempel (søk adresse + zoom): [{{"tool": "SearchAddress", "params": {{"address": "Nygårdsgaten 5, Bergen"}}}}, {{"tool": "ZoomMap", "params": {{"level": 16}}}}] // Senterer kartet + zoomer til 16
    Eksempel (panorering og zoom): [{{"tool": "PanMap", "params": {{"location": "Oslo"}}}}, {{"tool": "ZoomMap", "params": {{"level": 14}}}}] // Eksempel for panorering og zoom
    
    Du kan kjenne igjen disse handlingene:
    - Panorering: Når brukeren vil se et spesifikt sted (f.eks. "vis meg Oslo", "ta meg til Bergen")
    - Zooming: Når brukeren vil zoome inn eller ut (f.eks. "zoom til nivå 16", "zoom inn")
    - Markører: Når brukeren vil markere steder (f.eks. "marker Oslo og Bergen", "fjern alle markører")
    - Min posisjon: Finne eller markere brukerens posisjon (f.eks. "vis hvor jeg er", "marker min posisjon")
    """
    
    # Create tool calling prompt
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        ("human", "{query}")
    ])
    
    # Use the LLM to generate tool calls
    # NOTE: Assumes llm_manager is initialized globally or passed appropriately
    model = llm_manager.get_main_llm()
    chain = prompt | model | StrOutputParser()
    json_response = await chain.ainvoke({"query": latest_user_query})
    print(f"Raw LLM JSON response: {json_response}")
    
    try:
        # Clean up the response - remove markdown code blocks and backticks
        cleaned_response = json_response.replace("```json", "").replace("```", "").strip()
        print(f"Cleaned response: {cleaned_response}")
        
        # Try several approaches to extract valid JSON
        tool_calls_json = []
        
        # First attempt: Try to parse the entire response as JSON directly
        try:
            parsed_json = json.loads(cleaned_response)
            if isinstance(parsed_json, list):
                tool_calls_json = parsed_json
            elif isinstance(parsed_json, dict) and "tool" in parsed_json:
                tool_calls_json = [parsed_json]
            print(f"Successfully parsed full response as JSON: {tool_calls_json}")
        except json.JSONDecodeError:
            import re
            # Second attempt: Look for JSON array in the response
            array_match = re.search(r'\[(.*?)\]', cleaned_response.replace('\n', ' '), re.DOTALL)
            if array_match:
                try:
                    extracted_array = f"[{array_match.group(1)}]"
                    tool_calls_json = json.loads(extracted_array)
                    print(f"Successfully parsed JSON array: {tool_calls_json}")
                except json.JSONDecodeError:
                    print(f"Failed to parse JSON array: {extracted_array}")
            
            # Third attempt: Look for individual JSON objects if array parsing failed
            if not tool_calls_json:
                # Find all JSON objects in the text
                import re
                object_matches = re.finditer(r'\{(?:[^{}]|(?:\{[^{}]*\}))*\}', cleaned_response, re.DOTALL)
                for match in object_matches:
                    try:
                        obj = json.loads(match.group(0))
                        if "tool" in obj and "params" in obj:
                            tool_calls_json.append(obj)
                            print(f"Successfully parsed JSON object: {obj}")
                    except json.JSONDecodeError:
                        continue
        
        # Create tool calls array for the assistant message
        tool_calls = []
        for i, tool_call in enumerate(tool_calls_json):
            tool_name = tool_call.get("tool")
            params = tool_call.get("params", {})
            
            if not tool_name:
                continue
                
            tool_calls.append({
                "id": f"call_{i}",
                "function": {
                    "name": tool_name,
                    "arguments": json.dumps(params)
                }
            })
        
        print(f"Created {len(tool_calls)} tool calls: {tool_calls}")
        
        # Create a new assistant message with the tool calls
        assistant_message = {
            "role": "assistant",
            "content": json_response,
            "additional_kwargs": {
                "tool_calls": tool_calls
            }
        }
        
        # Add the message to the state
        current_messages = state.get("messages", []) # Get current messages
        new_messages = list(current_messages) + [assistant_message] # Append new message
        state["messages"] = new_messages # Update state
        
    except Exception as e:
        print(f"Error generating tool calls: {e}")
        import traceback
        traceback.print_exc()
        # Create an empty assistant message with no tool calls
        error_message = {
            "role": "assistant",
            "content": "Jeg forstår ikke hva du vil jeg skal gjøre med kartet.",
            "additional_kwargs": {"tool_calls": []}
        }
        current_messages = state.get("messages", []) # Get current messages
        new_messages = list(current_messages) + [error_message] # Append error message
        state["messages"] = new_messages # Update state
    
    return state

# --- Tool Node: Executes Tools ---

async def call_tools(state: Dict) -> Dict:
    """Execute the tool calls generated by the model."""
    print(f"Executing tools with state: {state.keys()}")
    
    messages = state.get("messages", [])
    if not messages:
        return state
    
    # Get the last message with tool calls
    last_message = messages[-1]
    if not isinstance(last_message, dict) or "additional_kwargs" not in last_message or "tool_calls" not in last_message["additional_kwargs"]:
        print("No tool calls found in the last message or last message not a dict")
        return state
    
    # Track map state for applying changes
    map_center = state.get("map_center", (59.9139, 10.7522))
    zoom_level = state.get("zoom_level", 14)
    markers = state.get("markers", [])[:]
    action_taken = state.get("action_taken", [])[:]
    # Reset action-specific flags
    state["add_marker_at_address"] = None
    state["found_address_text"] = None # Reset found address text each tool run
    
    # Execute each tool call
    tool_results = []
    for tool_call in last_message["additional_kwargs"]["tool_calls"]:
        try:
            # Create tool invocation (ensure arguments are parsed)
            tool_name = tool_call["function"]["name"]
            tool_input_str = tool_call["function"]["arguments"]
            tool_input_dict = json.loads(tool_input_str)
            
            action = ToolInvocation(
                tool=tool_name,
                tool_input=tool_input_dict,
                id=tool_call["id"],
            )
            
            # Track the action
            if action.tool not in action_taken:
                action_taken.append(action.tool)
            print(f"Executing tool: {action.tool} with arguments: {action.tool_input}")
            
            # Store tool result directly for potential use by response generation or subsequent tools
            tool_result_content = None
            
            # Call the appropriate tool function using the imported executor
            # tool_executor will find the correct function based on action.tool
            # Note: tool_executor.ainvoke expects a single action
            # We need to call the underlying functions directly here for state updates
            
            if tool_name == "PanMap":
                # Check if SearchAddress ran successfully earlier in *this* tool call sequence
                search_address_succeeded = bool(state.get("found_address_text")) 
                
                # Directly call the implementation
                tool_result_content = await pan_to_location(**action.tool_input)
                
                # Only update map_center from PanMap if SearchAddress hasn't already set it successfully
                if not search_address_succeeded:
                    if isinstance(tool_result_content, tuple) and len(tool_result_content) == 2:
                        map_center = tool_result_content
                        print(f"PanMap updating map_center: {map_center}")
                    else:
                         print(f"PanMap returned non-coordinate result, not updating map_center: {tool_result_content}")
                else:
                    print(f"PanMap skipping map_center update because SearchAddress succeeded earlier.")
                # We add PanMap when SearchAddress succeeds, so we don't need to add it again here if search_address_succeeded.
                if not search_address_succeeded and isinstance(tool_result_content, tuple) and len(tool_result_content) == 2:
                    if "PanMap" not in action_taken:
                         action_taken.append("PanMap")
                         
            elif tool_name == "ZoomMap":
                tool_result_content = await set_zoom_level(**action.tool_input)
                if isinstance(tool_result_content, int):
                     zoom_level = tool_result_content
                     print(f"ZoomMap updated zoom_level to: {zoom_level}")
                else:
                     print(f"ZoomMap returned non-int result: {tool_result_content}")
                     
            elif tool_name == "AddMarkers":
                tool_result_content = await add_markers(**action.tool_input)
                if isinstance(tool_result_content, list):
                    if action.tool_input.get("clear", False):
                        markers = tool_result_content
                        print(f"AddMarkers cleared and set markers: {markers}")
                    else:
                        # Avoid duplicates when extending
                        existing_marker_ids = {(m['lat'], m['lng']) for m in markers}
                        new_markers_to_add = [m for m in tool_result_content if (m['lat'], m['lng']) not in existing_marker_ids]
                        markers.extend(new_markers_to_add)
                        print(f"AddMarkers extended markers: {markers}")
                    # Ensure AddMarkers action is recorded if markers changed
                    if "AddMarkers" not in action_taken:
                        action_taken.append("AddMarkers")
                else:
                     print(f"AddMarkers returned non-list result: {tool_result_content}")
                     
            elif tool_name == "FindMyLocation":
                tool_result_content = await find_my_location(**action.tool_input)
                # Store add_marker preference from the input
                add_marker_pref = action.tool_input.get("add_marker", False)
                state["add_marker_at_location"] = add_marker_pref
                # Zoom level might be returned by the tool, update if so
                if isinstance(tool_result_content, dict) and "zoom_level" in tool_result_content:
                     returned_zoom = tool_result_content.get("zoom_level")
                     if isinstance(returned_zoom, int):
                          zoom_level = max(1, min(18, returned_zoom)) # Clamp zoom
                          print(f"FindMyLocation updated zoom_level to: {zoom_level}")
                     else:
                          # Use default if zoom invalid
                          zoom_level = 14
                          print(f"FindMyLocation returned invalid zoom, using default 14")
                else: 
                    # Use default zoom if not specified in tool return
                    zoom_level = 14 
                    print(f"FindMyLocation using default zoom 14")
                print(f"FindMyLocation tool completed. Add marker: {add_marker_pref}")
                # Action is already added at the start of the loop
                
            elif tool_name == "SearchAddress":
                tool_result_content = await search_address(**action.tool_input)
                coords = None
                label = None
                # Store add_marker preference from input
                add_marker_pref = action.tool_input.get("add_marker", False)
                state["add_marker_at_address"] = add_marker_pref
                
                if isinstance(tool_result_content, dict) and "coordinates" in tool_result_content:
                    coords = tool_result_content.get("coordinates")
                    label = tool_result_content.get("full_address")
                    state["found_address_text"] = label # Store full address text
                    
                    if coords:
                        map_center = coords
                        print(f"SearchAddress updated map_center to: {map_center}")
                        if "PanMap" not in action_taken:
                             action_taken.append("PanMap") # Implicit pan
                             
                        # Set default zoom if ZoomMap is not called in the *same* batch
                        zoom_map_called_in_batch = any(
                             tc["function"]["name"] == "ZoomMap" 
                             for tc in last_message["additional_kwargs"]["tool_calls"]
                        )
                        if not zoom_map_called_in_batch:
                            zoom_level = 14
                            print(f"SearchAddress setting default zoom to 14.")
                            if "ZoomMap" not in action_taken:
                                 action_taken.append("ZoomMap") # Implicit zoom
                                 
                    # Handle marker addition based on preference *now* that we have coords/label
                    if add_marker_pref and coords and label:
                        new_marker = {"lat": coords[0], "lng": coords[1], "label": label}
                        if new_marker not in markers:
                            markers.append(new_marker)
                            print(f"SearchAddress adding marker for: {label}")
                            if "AddMarkers" not in action_taken:
                                action_taken.append("AddMarkers")
                        else:
                            print(f"Marker for {label} already exists.")
                            
                elif isinstance(tool_result_content, dict) and "error" in tool_result_content:
                     print(f"SearchAddress returned error: {tool_result_content['error']}")
                     # Do not update map center or markers on error
                     state["found_address_text"] = None # Clear found text on error
                else:
                     print(f"SearchAddress returned unexpected result: {tool_result_content}")
                     state["found_address_text"] = None # Clear found text
                     
            else:
                raise ValueError(f"Unknown tool: {tool_name}")
            
            # Create a tool message with the *actual result* of the function call
            tool_message = {
                "role": "tool",
                "tool_call_id": tool_call["id"],
                "name": action.tool,
                # Store result consistently, prefer JSON string for dicts
                "content": json.dumps(tool_result_content) if isinstance(tool_result_content, dict) else str(tool_result_content)
            }
            tool_results.append(tool_message)
            
        except Exception as e:
            print(f"Error executing tool {tool_call['function']['name']}: {e}")
            traceback.print_exc()
            # Append an error message for this specific tool call
            tool_results.append({
                 "role": "tool",
                 "tool_call_id": tool_call["id"],
                 "name": tool_call['function']['name'],
                 "content": json.dumps({"error": f"Failed to execute tool: {e}"})
            })
    
    # Update the state with the new map state *after* all tools ran
    state["messages"] = list(messages) + tool_results # Append all tool results
    state["map_center"] = map_center
    state["zoom_level"] = zoom_level
    state["markers"] = markers
    state["action_taken"] = list(set(action_taken)) # Ensure unique actions
    
    # Found address text and marker prefs are already updated within the loop
    
    return state

# --- Response Node: Generates Final Text ---

async def generate_response(state: Dict) -> Dict:
    """Generate a response based on the map actions taken."""
    print(f"Generating response with state: {state.keys()}")
    
    messages = state.get("messages", [])
    if not messages:
        return state
    
    # Find the latest user query
    latest_query = None
    for msg in reversed(messages):
        role = None
        content = None
        if isinstance(msg, dict):
             role = msg.get("role")
             content = msg.get("content")
        elif hasattr(msg, 'type'): # BaseMessage
             role = msg.type
             content = msg.content
             
        if role == "human":
            latest_query = content
            break
    
    if not latest_query:
        latest_query = "Vis meg kartet" # Default query
    
    # --- Extract info from state and tool results for the prompt --- 
    action_taken = state.get("action_taken", [])
    location_name = None
    search_address_error = None
    search_address_called = False
    original_search_query = None
    found_address_text = state.get("found_address_text") # Use state value directly
    
    # Check tool results specifically for SearchAddress outcome
    for msg in reversed(messages):
        if isinstance(msg, dict) and msg.get("role") == "tool" and msg.get("name") == "SearchAddress":
            search_address_called = True
            try:
                tool_content_str = msg.get("content", "{}")
                tool_content = json.loads(tool_content_str) # Parse the content string
                if isinstance(tool_content, dict) and "error" in tool_content:
                    search_address_error = tool_content["error"]
                    print(f"generate_response: Found SearchAddress error in tool result: {search_address_error}")
                    
                # Find the original address query from the corresponding assistant tool call
                tool_call_id = msg.get("tool_call_id")
                if tool_call_id:
                    for prev_msg in reversed(messages):
                        if isinstance(prev_msg, dict) and prev_msg.get("role") == "assistant":
                             tool_calls = prev_msg.get("additional_kwargs", {}).get("tool_calls", [])
                             for tc in tool_calls:
                                 if tc.get("id") == tool_call_id and tc.get("function", {}).get("name") == "SearchAddress":
                                     try:
                                         args_str = tc["function"]["arguments"]
                                         call_args = json.loads(args_str)
                                         original_search_query = call_args.get("address")
                                         print(f"generate_response: Original SearchAddress query: {original_search_query}")
                                         break # Found args for this tool call
                                     except Exception as e:
                                         print(f"Error extracting original search query args: {e}")
                             if original_search_query: # Stop searching previous messages
                                 break 
                                 
            except json.JSONDecodeError:
                search_address_error = "Could not parse SearchAddress tool result."
                print(f"generate_response: Error parsing SearchAddress content: {tool_content_str}")
            except Exception as e:
                search_address_error = f"Error processing SearchAddress tool result: {e}"
                print(f"generate_response: Unexpected error processing SearchAddress result: {e}")
            break # Stop searching after finding the latest SearchAddress tool result

    # Determine location name for response (prefer found address, fallback to PanMap arg)
    if found_address_text:
        location_name = found_address_text
        print(f"generate_response: Using found address as location_name: {location_name}")
    elif "PanMap" in action_taken and not search_address_called: # Only use PanMap arg if not an address search
        # Find the *input* argument to the PanMap tool call
        for msg in reversed(messages):
             if isinstance(msg, dict) and msg.get("role") == "tool" and msg.get("name") == "PanMap":
                 tool_call_id = msg.get("tool_call_id")
                 if tool_call_id:
                    for prev_msg in reversed(messages):
                        if isinstance(prev_msg, dict) and prev_msg.get("role") == "assistant":
                            tool_calls = prev_msg.get("additional_kwargs", {}).get("tool_calls", [])
                            for tc in tool_calls:
                                if tc.get("id") == tool_call_id and tc.get("function", {}).get("name") == "PanMap":
                                    try:
                                        args_str = tc["function"]["arguments"]
                                        location_args = json.loads(args_str)
                                        loc_arg = location_args.get("location")
                                        # Basic check to avoid using coordinate strings as names
                                        if loc_arg and not (loc_arg.startswith('[') and loc_arg.endswith(']')):
                                            location_name = loc_arg
                                            print(f"generate_response: Found location in PanMap tool call args: {location_name}")
                                        break # Found args
                                    except Exception as e:
                                        print(f"Error extracting PanMap location arg: {e}")
                            if location_name: break # Stop inner loop
                    if location_name: break # Stop outer loop
                 break # Stop searching tool messages

    # Create a response prompt template
    prompt_template = """Du er en kartassistent. Generer et svar basert på handlingene som ble utført og resultatet av verktøykall.
        
Handlinger utført: {actions}
Kartsentrum: {map_center}
Zoom-nivå: {zoom_level}
Markører: {markers_count}
        
VIKTIG:
- Hvis SearchAddress ble kalt ({search_address_called}) og mislyktes med feilmeldingen: '{search_address_error}', informer brukeren KLART om at adressen '{original_search_query}' ikke ble funnet. Ikke si noe annet.
- Hvis SearchAddress var vellykket og fant adressen '{found_address}', bekreft at kartet viser denne adressen. Nevn også hvis markør ble lagt til.
- Hvis PanMap ble brukt for et generelt stedsnavn '{location}', bekreft at kartet viser dette stedet.
- Hvis kun andre handlinger ble utført (zoom, markører, min posisjon), beskriv disse kort.
- Hvis FindMyLocation ble brukt, si at kartet viser brukerens posisjon. Nevn også hvis markør ble lagt til.
- Ikke dikt opp informasjon. Svar kun basert på handlingene og resultatene.
        
Eksempel (adresse ikke funnet): Beklager, jeg fant ingen adresse som heter 'Helvetesgata 12'.
Eksempel (adresse funnet + markør): Ok, jeg har sentrert kartet på Eidsdalen 7B og la til en markør.
Eksempel (adresse funnet, ingen markør): Greit, kartet viser nå Eidsdalen 7B.
Eksempel (sted funnet): Kartet viser nå Oslo.
Eksempel (kun zoom): Jeg har zoomet inn på kartet.
Eksempel (min posisjon + markør): Ok, kartet viser nå din posisjon, og jeg har lagt til en markør der.
        
Hold svaret KORT, konsist og direkte relatert til handlingene.
"""

    prompt = ChatPromptTemplate.from_messages([
        ("system", prompt_template),
        # We include the *history* here so the LLM has context if needed,
        # but the system prompt guides it to focus on the *latest* actions/results.
        # Use a simplified history format for the prompt context
        # messages_to_llm = _prepare_messages_for_llm(messages)
        #*messages_to_llm, # Unpack the prepared messages
        ("human", "{query}") # Include the latest query for context
    ])
    
    # Prepare data for the prompt
    prompt_data = {
        "query": latest_query,
        "actions": ", ".join(action_taken) if action_taken else "ingen",
        "map_center": state.get("map_center", (59.9139, 10.7522)),
        "location": location_name or "kartet",
        "zoom_level": state.get("zoom_level", 14),
        "markers_count": len(state.get("markers", [])),
        "found_address": found_address_text or "",
        "search_address_called": search_address_called,
        "search_address_error": search_address_error or "", 
        "original_search_query": original_search_query or ""
    }
    
    print(f"generate_response: Prompt data: {prompt_data}")
    
    # Generate the response
    # NOTE: Assumes llm is initialized globally or passed appropriately
    chain = prompt | llm | StrOutputParser()
    response_content = await chain.ainvoke(prompt_data)
    
    print(f"generate_response: Generated response content: {response_content}")
    
    # Add the response to the messages list in the state
    final_assistant_message = {"role": "assistant", "content": response_content}
    current_messages = state.get("messages", [])
    new_messages = list(current_messages) + [final_assistant_message]
    state["messages"] = new_messages
    # Update chat history string if needed elsewhere
    state["chat_history"] = format_history(new_messages)
    
    return state

# --- Update Node: Sends Data to Frontend ---

async def send_map_update(state: Dict) -> Dict:
    """Send the map update to the frontend via websocket."""
    print(f"Sending map update with state: {state.keys()}")
    
    # Standardize the state (though wrapper should handle this)
    state = standardize_state(state) 
    
    is_mixed_workflow = state.get("in_merged_workflow", False)
    print(f"DEBUG send_map_update: in_merged_workflow flag = {is_mixed_workflow}")
    
    websocket_id = state.get("websocket_id")
    if not websocket_id:
        print("ERROR: No websocket ID found in state for send_map_update")
        return state
        
    # NOTE: Assumes active_websockets is accessible
    websocket = active_websockets.get(websocket_id)
    
    if websocket:
        try:
            action_taken = state.get("action_taken", [])
            map_data = {}
            
            # Center Update: Triggered by PanMap or FindMyLocation
            if "PanMap" in action_taken or "FindMyLocation" in action_taken:
                 map_center = state.get("map_center")
                 if map_center:
                      map_data["center"] = map_center
                 else: # FindMyLocation needs client side action
                      if "FindMyLocation" in action_taken:
                           map_data["findMyLocation"] = True # Trigger client-side location
                           # Add marker preference for FindMyLocation if applicable
                           add_marker_loc = state.get("add_marker_at_location", False)
                           if add_marker_loc:
                                map_data["addMarker"] = True # Add marker at user's location
            
            # Marker Update: Triggered by AddMarkers
            # Includes markers added by SearchAddress (which adds AddMarkers to action_taken)
            # Also handles markers added by FindMyLocation (via addMarker flag above)
            if "AddMarkers" in action_taken:
                markers = state.get("markers")
                if markers is not None: # Send even if empty list if action was taken
                     map_data["markers"] = markers
                # Check if markers were cleared (check tool input, not stored in state currently)
                # This requires looking back at tool inputs, maybe simplify?
                # For now, assume client handles clearing if markers list is empty.
                # map_data["clearMarkers"] = state.get("clear_markers", False) # Needs state update
            
            # Zoom Update: Triggered by ZoomMap 
            # SearchAddress also triggers ZoomMap implicitly if needed
            if "ZoomMap" in action_taken:
                 zoom = state.get("zoom_level")
                 if zoom is not None:
                      map_data["zoom"] = zoom
            
            print(f"Sending map update data: {map_data}")
            
            # Only send if there's actual map data to send
            if map_data:
                try:
                    await send_websocket_message("mapUpdate", map_data, websocket)
                    print(f"Successfully sent mapUpdate to websocket {websocket_id}")
                except Exception as e:
                    print(f"ERROR: Failed to send mapUpdate message: {e}")
            else:
                 print("No map data changes detected to send.")

            # --- Chat Message Handling --- 
            # Only send chat response if not in mixed workflow
            if not is_mixed_workflow:
                print(f"Not in mixed workflow, attempting to send chat message.")
                messages = state.get("messages", [])
                if messages:
                    # Get the latest assistant message using utility function
                    assistant_response_content = get_last_message_by_role(messages, "assistant")
                    
                    if assistant_response_content:
                        print(f"Streaming final assistant response: {assistant_response_content[:100]}...")
                        # Stream the message
                        await send_websocket_message("chatStream", {"payload": assistant_response_content, "isNewMessage": True}, websocket)
                        # Signal completion
                        await send_websocket_message("streamComplete", {}, websocket)
                        print("Chat stream sent successfully.")
                    else:
                        print("No assistant message content found in final state to stream.")
                else:
                    print("No messages found in final state to extract assistant response.")
            else:
                print(f"Suppressing map agent chat response in mixed workflow mode.")
                
        except Exception as e_inner:
             print(f"ERROR: Exception caught within send_map_update logic: {e_inner}")
             traceback.print_exc()
    else:
        print(f"ERROR: No websocket found for ID: {websocket_id} in send_map_update")
        print(f"DEBUG: Available websocket IDs: {list(active_websockets.keys())}")
    
    # Ensure the function always returns the state dictionary
    return state 